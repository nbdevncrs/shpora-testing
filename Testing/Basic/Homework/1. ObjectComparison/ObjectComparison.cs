using FluentAssertions;
using FluentAssertions.Equivalency;
using NUnit.Framework;
using NUnit.Framework.Legacy;

namespace HomeExercise.Tasks.ObjectComparison;

public class ObjectComparison
{
    [Test]
    [Description("Проверка текущего царя")]
    public void TsarRegistry_ShouldReturnExpectedCurrentTsar_Test()
    {
        var actualTsar = TsarRegistry.GetCurrentTsar();
        var expectedTsar = GetExpectedCurrentTsar();

        actualTsar.Should().BeEquivalentTo(expectedTsar, config => config
            .Excluding((IMemberInfo info) => info.Name == "Id")
            .IgnoringCyclicReferences());

        /*
         Заменяем на Should().BeEquivalentTo() из Fluent Assertions.
         BeEquivalentTo проверяет два объекта необязательно одного класса на совпадение одноименных полей,
         на совпадение полей объектов, которые могут находиться в качестве ссылок в полях сравниваемых объектов
         (как в случае с Parent внутри класса Person)
         Здесь не хватит цепочки Should().BeEquivalentTo(), ведь метод сравнивает все поля
         (в том числе поля объектов, которые лежат в полях в виде ссылки сравниваемого объекта),
         и здесь нам мешают Id, ведь в тесте мы создаем новые объекты класса, Id у объектов разные
         Мы работаем с настройками данного assertion-метода, исключая из проверки поля с айдишниками
         Считаю, что лучше исключать конкретные поля, даже если их несколько, не используя EndsWith, чтобы
         не возникало проблем с тем, что чудом может появится поле, которое оканчивается на Id и его необходимо
         включать в проверку, а с EndsWith мы его пропустим.
         Если actualTsar == null || expectedTsar == null, то выдает false, как и предполагается.

         Уточнения:
         1. Если мы захотим создать класс, похожий на Person и сравнить, то проверка пройдет, но необходимо
         осознавать, что если в actual будет какое-то поле, которого нет в expected, то по проверке объекты не
         будут "эквивалентны", а если наоборот, в expected найдутся все поля actual, но expected будет содержать
         лишние поля, то тест будет пройден успешно, поэтому разные классы лучше не использовать, такое "расширение"
         может ломать логику теста и выдавать некорректные результаты без внесения изменений
         2. Такое построение теста дает полную возможность добавлять практически любые поля без внесения
         изменений в тест, если мы остаемся в рамках одно и того же класса, ведь метод сам пробегается по всем полям
         без уточнений в его параметрах или в тесте в целом. Исключение и проблема - поля, которые схожи с Id,
         то есть являются какой-то "внутрянкой" и используются исключительно при работе с объектами класса в коде,
         при их появлении тест начнет падать, но хотя бы этим падением даст о себе знать и разработчик сможет
         быстро добавить лишний .Excluding() в тест
        */
    }

    [Test]
    [Description("Альтернативное решение. Какие у него недостатки?")]
    public void TsarRegistry_ShouldReturnExpectedCurrentTsar_WithCustomEquality_Test()
    {
        var actualTsar = TsarRegistry.GetCurrentTsar();
        var expectedTsar = GetExpectedCurrentTsar();

        // Какие недостатки у такого подхода? 
        ClassicAssert.True(AreEqual(actualTsar, expectedTsar));
    }

    private bool AreEqual(Person? actual, Person? expected)
    {
        if (actual == expected) return true;
        if (actual == null || expected == null) return false;
        return
            actual.Name == expected.Name
            && actual.Age == expected.Age
            && actual.Height == expected.Height
            && actual.Weight == expected.Weight
            && AreEqual(actual.Parent, expected.Parent);
    }

    private static Person GetExpectedCurrentTsar()
    {
        var expectedTsarParent = new Person("Vasili III of Russia", 28, 170, 60, null);
        return new Person("Ivan IV The Terrible", 54, 170, 70, expectedTsarParent);
    }

    /*
      Недостатки альтернативного решения:

      1. Альтернативное решение не позволяет спокойно расширять функциональность класса, а точнее добавлять новые поля
      в класс, объекты которого мы сравниваем.
      Мы в любом случае должны вносить изменения в AreEqual, который при всем при этом лежит внутри файла с тестами,
      то есть он не является методом класса, объекты которого мы сравниваем. Разработчик мог бы сразу изменить
      подобный метод сравнения при появлении новых полей, если бы он использовался в рамках работы с классом вне тестов
      В данном случае тест упадет при появлении новых полей, если разработчик не знает о внутрянках тестов или не лезет
      туда вообще, хотя появление новых полей (исключая что-то по типу Id) никак не должно влиять на исход работы теста

      2. Альтернативное решение при запуске теста и появлении какого-то несовпадения не дает никаких подробностей
      по тому, что вообще произошло. При использовании булевого утверждения увидим, что Expected: True, But was: False
      Данная информация не помогает проблему решить, а использование Fluent Assertions дает подробную информацию

      3. Читаемость: в целом очень легко понять, что делает данный тест, не заглядывая в AreEqual.
      Однако, если мы хотим вникнуть в подробности, что конкретно происходит в тесте, то мы опускаем глаза и видим
      не очень большой но неприятный отрывок кода, в котором необходимо разобраться. Тут даже используется рекурсия,
      чтобы проверять объект по ссылке на родителя (рекурсия имеет свойство вызывать переполнение стека, чисто
      теоретически это может произойти и здесь, если человек чудом сам себе родитель, нет проверки на
      циклические ссылки). Относительно "моего" решения разница безусловно есть, но назвать читаемость явной
      проблемой этого решения нельзя, слегка приятнуто за уши

      Небольшой плюс альтернативного решения:
      Оно будет быстрее использования BeEquivalentTo(), по информации из интернета метод из Fluent Assertions
      использует рефлексию и может быть в 10 раз медленее альтернативного решения, что в целом не так критично
      исходя из сложности обоих методов, отсюда вытекает и небольшой минус выбранного мной решения.
    */
}